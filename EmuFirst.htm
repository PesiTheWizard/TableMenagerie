<html>
<head>
<title>NES emulator test</title>
<script>
const IllegalOpcode = () => {console.log("An undocumented opcode was run");};
const HaltAndCatchFire = () => {console.log("CPU halted and caught fire");};
const NESCPU = [
	() => {//$00 BRK Cycles=7 Bytes=1; Implied
		PC16[0]++;//It just does that
		TheStack[Register[SP]] = PC8[1];
		Register[SP]--;
		TheStack[Register[SP]] = PC8[0];
		Register[SP]--;
		Flag_B = true;
		TheStack[Register[SP]] = statusToByte();
		Register[SP]--;
		PC8[0] = MemoryIn2Parts[HCPC][IRQ];
		PC8[1] = MemoryIn2Parts[HCPC][IRQ+1];
	},
	() => {//$01 ORA Cycles=6 Bytes=2; (Indirect,X)
		anotherTempByte[0] = MemoryIn2Parts[PC8[1]][PC8[0]];
		PC16[0]++;//For the byte-read above
		anotherTempByte[0]+=Register[X];
		indU8[0] = ZeroPage[anotherTempByte[0]];
		anotherTempByte[0]++;
		indU8[1] = ZeroPage[anotherTempByte[0]];
		Register[A] |= MemoryIn2Parts[indU8[1]][indU8[0]];
		Flag_Zero = !Register[A];
		Flag_Negative = (SignedRegister[A] < 0);
	},
	HaltAndCatchFire,//$02
	IllegalOpcode,//$03
	() => {//IllegalOpcode, $04 NOP Cycles=3 Bytes=2
		PC16[0]++;
	},
	() => {//$05 ORA Cycles=3 Bytes=2; Zero Page
		indU8[0] = MemoryIn2Parts[PC8[1]][PC8[0]];
		PC16[0]++;//For the byte-read above
		Register[A] |= ZeroPage[indU8[0]];
		Flag_Zero = !Register[A];
		Flag_Negative = (SignedRegister[A] < 0);
	},
	() => {//$06 ASL Cycles=5 Bytes=2; Zero Page
		indU8[0] = MemoryIn2Parts[PC8[1]][PC8[0]];
		PC16[0]++;//For the byte-read above
		Flag_Carry = ((ZeroPage[indU8[0]]>>>7)&1)==1;
		ZeroPage[indU8[0]]<<=1;
		indU8[0] = ZeroPage[indU8[0]];//to check the flags
		Flag_Zero = !indU8[0];
		Flag_Negative = (ind8[0] < 0);
	},
	IllegalOpcode,//$07
	() => {//$08 PHP Cycles=3 Bytes=1; Implied
		Flag_B = true;
		TheStack[Register[SP]] = statusToByte();
		Register[SP]--;
	},
	() => {//$09 ORA Cycles=2 Bytes=2; Immediate
		Register[A] |= MemoryIn2Parts[PC8[1]][PC8[0]];
		PC16[0]++;//For the byte-read above
		Flag_Zero = !Register[A];
		Flag_Negative = (SignedRegister[A] < 0);
	},
	() => {//$0A ASL Cycles=2 Bytes=1; Accumulator
		Flag_Carry = (Register[A]&(0x80))==0x80;
		Register[A] = Register[A]<<1;
		Flag_Zero = !Register[A];
		Flag_Negative = (SignedRegister[A] < 0);
	},
	IllegalOpcode,//$0B
	IllegalOpcode,//$0C
	() => {//$0D ORA Cycles=4 Bytes=3; Absolute
		indU8[0] = MemoryIn2Parts[PC8[1]][PC8[0]];
		PC16[0]++;//For the byte-read above
		indU8[1] = MemoryIn2Parts[PC8[1]][PC8[0]];
		PC16[0]++;//For the byte-read above
		Register[A] |= MemoryIn2Parts[indU8[1]][indU8[0]];
		Flag_Zero = !Register[A];
		Flag_Negative = (SignedRegister[A] < 0);
	},
	() => {//$0E ASL Cycles=6 Bytes=3; Absolute
		indU8[0] = MemoryIn2Parts[PC8[1]][PC8[0]];
		PC16[0]++;//For the byte-read above
		indU8[1] = MemoryIn2Parts[PC8[1]][PC8[0]];
		PC16[0]++;//For the byte-read above
		reader(indU8[0],indU8[1],anotherTempByte,0);
		const newCarry = !!(anotherTempByte[0]>>>7);
		anotherTempByte[0] = (anotherTempByte[0]<<1);
		writer(indU8[0],indU8[1],anotherTempByte[0]);
		Flag_Carry = newCarry;
		Flag_Zero = !anotherTempByte[0];
		Flag_Negative = !!(anotherTempByte[0]>>>7);
	},
	IllegalOpcode,//$0F
	() => {//$10 BPL Cycles=2-4 Bytes=2; Relative
		indU8[0] = MemoryIn2Parts[PC8[1]][PC8[0]];
		PC16[0]++;//For the byte-read above
		if(!Flag_Negative)//Branch condition
		{
			PC16[0]+=ind8[0];//operand counts as signed
			//Possibly add 1 to cycle count
			//also possibly compare PC8[0] to former for more cycle counts
		}
	},
	() => {//$11 ORA Cycles=5-6 Bytes=2; (Indirect),Y
		anotherTempByte[0] = MemoryIn2Parts[PC8[1]][PC8[0]];
		PC16[0]++;//For the byte-read above
		indU8[0] = ZeroPage[anotherTempByte[0]];
		anotherTempByte[0]++;
		indU8[1] = ZeroPage[anotherTempByte[0]];
		indU16[0]+=Register[Y];
		Register[A] |= MemoryIn2Parts[indU8[1]][indU8[0]];
		Flag_Zero = !Register[A];
		Flag_Negative = (SignedRegister[A] < 0);
	},
	HaltAndCatchFire,//$12
	IllegalOpcode,//$13
	IllegalOpcode,//$14
	() => {//$15 ORA Cycles=4 Bytes=2; Zero Page,X
		indU8[0] = MemoryIn2Parts[PC8[1]][PC8[0]];
		PC16[0]++;//For the byte-read above
		indU8[0]+=Register[X];//automatically loops
		Register[A] |= ZeroPage[indU8[0]];
		Flag_Zero = !Register[A];
		Flag_Negative = (SignedRegister[A] < 0);
	},
	() => {//$16 ASL Cycles=6 Bytes=2; Zero Page,X
		indU8[0] = MemoryIn2Parts[PC8[1]][PC8[0]];
		PC16[0]++;//For the byte-read above
		indU8[0]+=Register[X];//automatically loops
		Flag_Carry = ((ZeroPage[indU8[0]]>>>7)&1)==1;
		ZeroPage[indU8[0]]<<=1;
		indU8[0] = ZeroPage[indU8[0]];//to check the flags
		Flag_Zero = !indU8[0];
		Flag_Negative = (ind8[0] < 0);
	},
	IllegalOpcode,//$17
	() => {//$18 CLC Cycles=2 Bytes=1; Implied
		Flag_Carry = false;
	},
	() => {//$19 ORA Cycles=4-5 Bytes=3; Absolute,Y
		indU8[0] = MemoryIn2Parts[PC8[1]][PC8[0]];
		PC16[0]++;//For the byte-read above
		indU8[1] = MemoryIn2Parts[PC8[1]][PC8[0]];
		PC16[0]++;//For the byte-read above
		indU16[0]+=Register[Y];
		Register[A] |= MemoryIn2Parts[indU8[1]][indu8[0]];
		Flag_Zero = !Register[A];
		Flag_Negative = (SignedRegister[A] < 0);
	},
	IllegalOpcode,//$1A
	IllegalOpcode,//$1B
	IllegalOpcode,//$1C
	() => {//$1D ORA Cycles=4-5 Bytes=3; Absolute,X
		indU8[0] = MemoryIn2Parts[PC8[1]][PC8[0]];
		PC16[0]++;//For the byte-read above
		indU8[1] = MemoryIn2Parts[PC8[1]][PC8[0]];
		PC16[0]++;//For the byte-read above
		indU16[0]+=Register[X];
		Register[A] |= MemoryIn2Parts[indU8[1]][indu8[0]];
		Flag_Zero = !Register[A];
		Flag_Negative = (SignedRegister[A] < 0);
	},
	() => {//$1E ASL Cycles=7 Bytes=3; Absolute,X
		console.log("1E ASL was run");
	},
	IllegalOpcode,//$1F
	() => {//#20 JSR Cycles=6 Bytes=3; Absolute
		indU8[0] = MemoryIn2Parts[PC8[1]][PC8[0]];
		PC16[0]++;//For the byte-read above
		indU8[1] = MemoryIn2Parts[PC8[1]][PC8[0]];
		//Uniquely, this one doesn't increment Program Counter from 2nd read
		TheStack[Register[SP]] = PC8[1];
		Register[SP]--;
		TheStack[Register[SP]] = PC8[0];
		Register[SP]--;
		PC16[0] = indU16[0];
	},
	() => {//#21 AND Cycles=6 Bytes=2; (Indirect,X)
		anotherTempByte[0] = MemoryIn2Parts[PC8[1]][PC8[0]];
		PC16[0]++;//For the byte-read above
		anotherTempByte[0]+=Register[X];
		indU8[0] = ZeroPage[anotherTempByte[0]];
		anotherTempByte[0]++;
		indU8[1] = ZeroPage[anotherTempByte[0]];
		Register[A] &= MemoryIn2Parts[indU8[1]][indU8[0]];
		Flag_Zero = !Register[A];
		Flag_Negative = (SignedRegister[A] < 0);
	},
	HaltAndCatchFire,//$22
	IllegalOpcode,//$23
	() => {//$24 BIT Cycles=3 Bytes=2; Zero Page
		indU8[0] = MemoryIn2Parts[PC8[1]][PC8[0]];
		PC16[0]++;//For the byte-read above
		const temp = ZeroPage[indU8[0]];
		Flag_Zero = !(Register[A] & temp);
		Flag_Overflow = !!((temp>>>6)&1);
		Flag_Negative = !!((temp>>>7)&1);
	},
	() => {//$25 AND Cycles=3 Bytes=2; Zero Page
		console.log("25 AND was run");
	},
	() => {//$26 ROL Cycles=5 Bytes=2; Zero Page
		anotherTempByte[0] = MemoryIn2Parts[PC8[1]][PC8[0]];
		PC16[0]++;//For the byte-read above
		indU8[0] = ZeroPage[anotherTempByte[0]];
		const newCarry = (ind8[0] < 0);
		indU8[1] = (indU8[0]<<1)|Flag_Carry;
		ZeroPage[anotherTempByte[0]] = indU8[1];
		Flag_Carry = newCarry;
		Flag_Zero = !indU8[1];
		Flag_Negative = (ind8[1] < 0);
	},
	IllegalOpcode,//$27
	() => {//$28 PLP Cycles=4 Bytes=1; Implied
		Register[SP]++;
		byteToStatus(TheStack[Register[SP]]);
	},
	() => {//$29 AND Cycles=2 Bytes=2; Immediate
		indU8[0] = MemoryIn2Parts[PC8[1]][PC8[0]];
		PC16[0]++;//For the byte-read above
		Register[A] &= indU8[0];
		Flag_Zero = !Register[A];
		Flag_Negative = (SignedRegister[A] < 0);
	},
	() => {//$2A ROL Cycles=2 Bytes=1; Accumulator
		const newCarry = !!(Register[A]>>>7);
		Register[A] = (Register[A]<<1)|Flag_Carry;
		Flag_Carry = newCarry;
		Flag_Zero = !Register[A];
		Flag_Negative = (SignedRegister[A] < 0);
	},
	IllegalOpcode,//$2B
	() => {//$2C BIT Cycles=4 Bytes=3; Absolute
		console.log("2C BIT was run");
	},
	() => {//$2D AND Cycles=4 Bytes=3; Absolute
		console.log("2D AND was run");
	},
	() => {//$2E ROL Cycles=6 Bytes=3; Absolute
		indU8[0] = MemoryIn2Parts[PC8[1]][PC8[0]];
		PC16[0]++;//For the byte-read above
		indU8[1] = MemoryIn2Parts[PC8[1]][PC8[0]];
		PC16[0]++;//For the byte-read above
		reader(indU8[0],indU8[1],anotherTempByte,0);
		const newCarry = !!(anotherTempByte[0]>>>7);
		anotherTempByte[0] = (anotherTempByte[0]<<1)|Flag_Carry;
		writer(indU8[0],indU8[1],anotherTempByte[0]);
		Flag_Carry = newCarry;
		Flag_Zero = !anotherTempByte[0];
		Flag_Negative = !!(anotherTempByte[0]>>>7);
	},
	IllegalOpcode,//$2F
	() => {//$30 BMI Cycles=2-5 Bytes=2; Relative
		indU8[0] = MemoryIn2Parts[PC8[1]][PC8[0]];
		PC16[0]++;//For the byte-read above
		if(Flag_Negative)//Branch condition
		{
			PC16[0]+=ind8[0];//operand counts as signed
			//Possibly add 1 to cycle count
			//also possibly compare PC8[0] to former for more cycle counts
		}
	},
	() => {//$31 AND Cycles=5-6 Bytes=2; (Indirect),Y
		anotherTempByte[0] = MemoryIn2Parts[PC8[1]][PC8[0]];
		PC16[0]++;//For the byte-read above
		indU8[0] = ZeroPage[anotherTempByte[0]];
		anotherTempByte[0]++;
		indU8[1] = ZeroPage[anotherTempByte[0]];
		indU16[0]+=Register[Y];
		Register[A] &= MemoryIn2Parts[indU8[1]][indU8[0]];
		Flag_Zero = !Register[A];
		Flag_Negative = (SignedRegister[A] < 0);
	},
	HaltAndCatchFire,//$32
	IllegalOpcode,//$33
	IllegalOpcode,//$34
	() => {//$35 AND Cycles=4 Bytes=2; Zero Page,X
		indU8[0] = MemoryIn2Parts[PC8[1]][PC8[0]];
		PC16[0]++;//For the byte-read above
		indU8[0]+=Register[X];//automatically loops
		Register[A] &= ZeroPage[indU8[0]];
		Flag_Zero = !Register[A];
		Flag_Negative = (SignedRegister[A] < 0);
	},
	() => {//$36 ROL Cycles=6 Bytes=2; Zero Page,X
		console.log("36 ROL was run");
	},
	IllegalOpcode,//$37
	() => {//$38 SEC Cycles=2 Bytes=1; Implied
		Flag_Carry = true;
	},
	() => {//$39 AND Cycles=4-5 Bytes=3; Absolute,Y
		console.log("39 AND was run");
	},
	IllegalOpcode,//$3A
	IllegalOpcode,//$3B
	IllegalOpcode,//$3C
	() => {//$3D AND Cycles=4-5 Bytes=3; Absolute,X
		console.log("3D AND was run");
	},
	() => {//$3E ROL Cycles=7 Bytes=3; Absolute,X
		console.log("3E ROL was run");
	},
	IllegalOpcode,//$3F
	() => {//$40 RTI Cycles=6 Bytes=1; Implied
		Register[SP]++;
		byteToStatus(TheStack[Register[SP]]);
		Register[SP]++;
		indU8[0] = TheStack[Register[SP]];
		Register[SP]++;
		indU8[1] = TheStack[Register[SP]];
		PC16[0] = indU16[0];
	},
	() => {//$41 EOR Cycles=6 Bytes=2; (Indirect,X)
		anotherTempByte[0] = MemoryIn2Parts[PC8[1]][PC8[0]];
		PC16[0]++;//For the byte-read above
		anotherTempByte[0]+=Register[X];
		indU8[0] = ZeroPage[anotherTempByte[0]];
		anotherTempByte[0]++;
		indU8[1] = ZeroPage[anotherTempByte[0]];
		Register[A] ^= MemoryIn2Parts[indU8[1]][indU8[0]];
		Flag_Zero = !Register[A];
		Flag_Negative = (SignedRegister[A] < 0);
	},
	HaltAndCatchFire,//$42
	IllegalOpcode,//$43
	IllegalOpcode,//$44
	() => {//$45 EOR Cycles=3 Bytes=2; Zero Page
		indU8[0] = MemoryIn2Parts[PC8[1]][PC8[0]];
		PC16[0]++;//For the byte-read above
		Register[A] ^= ZeroPage[indU8[0]];
		Flag_Zero = !Register[A];
		Flag_Negative = (SignedRegister[A] < 0);
	},
	() => {//$46 LSR Cycles=5 Bytes=2; Zero Page
		indU8[0] = MemoryIn2Parts[PC8[1]][PC8[0]];
		PC16[0]++;//For the byte-read above
		Flag_Carry = (ZeroPage[indU8[0]]&1)==1;
		ZeroPage[indU8[0]]>>>=1;
		indU8[0] = ZeroPage[indU8[0]];//to check the flags
		Flag_Zero = !indU8[0];
		Flag_Negative = (ind8[0] < 0);
	},
	IllegalOpcode,//$47
	() => {//$48 PHA Cycles=3 Bytes=1; Implied
		TheStack[Register[SP]] = Register[A];
		Register[SP]--;
	},
	() => {//$49 EOR Cycles=2 Bytes=2; Immediate
		Register[A] ^= MemoryIn2Parts[PC8[1]][PC8[0]];
		PC16[0]++;//For the byte-read above
		Flag_Zero = !Register[A];
		Flag_Negative = (SignedRegister[A] < 0);
	},
	() => {//$4A LSR Cycles=2 Bytes=1; Accumulator
		Flag_Carry = !!(Register[A]&1);
		Register[A] = Register[A]>>>1;
		Flag_Zero = !Register[A];
		Flag_Negative = (SignedRegister[A] < 0);
	},
	IllegalOpcode,//$4B
	() => {//$4C JMP Cycles=3 Bytes=3; Absolute
		indU8[0] = MemoryIn2Parts[PC8[1]][PC8[0]];
		PC16[0]++;//For the byte-read above
		indU8[1] = MemoryIn2Parts[PC8[1]][PC8[0]];
		PC16[0] = indU16[0];
	},
	() => {//$4D EOR Cycles=4 Bytes=3; Absolute
		indU8[0] = MemoryIn2Parts[PC8[1]][PC8[0]];
		PC16[0]++;//For the byte-read above
		indU8[1] = MemoryIn2Parts[PC8[1]][PC8[0]];
		PC16[0]++;//For the byte-read above
		Register[A] ^= MemoryIn2Parts[indU8[1]][indU8[0]];
		Flag_Zero = !Register[A];
		Flag_Negative = (SignedRegister[A] < 0);
	},
	() => {//$4E LSR Cycles=6 Bytes=3; Absolute
		console.log("4E LSR was run");
	},
	IllegalOpcode,//$4F
	() => {//$50 BVC Cycles=2-5 Bytes=2; Relative
		indU8[0] = MemoryIn2Parts[PC8[1]][PC8[0]];
		PC16[0]++;//For the byte-read above
		if(!Flag_Overflow)//Branch condition
		{
			PC16[0]+=ind8[0];//operand counts as signed
			//Possibly add 1 to cycle count
			//also possibly compare PC8[0] to former for more cycle counts
		}
	},
	() => {//$51 EOR Cycles=5-6 Bytes=2; (Indirect),Y
		anotherTempByte[0] = MemoryIn2Parts[PC8[1]][PC8[0]];
		PC16[0]++;//For the byte-read above
		indU8[0] = ZeroPage[anotherTempByte[0]];
		anotherTempByte[0]++;
		indU8[1] = ZeroPage[anotherTempByte[0]];
		//done using anotherTempByte here, may reuse
		indU16[0]+=Register[Y];
		Register[A] ^= MemoryIn2Parts[indU8[1]][indU8[0]];
		Flag_Zero = !Register[A];
		Flag_Negative = (SignedRegister[A] < 0);
	},
	HaltAndCatchFire,//$52
	IllegalOpcode,//$53
	IllegalOpcode,//$54
	() => {//$55 EOR Cycles=4 Bytes=2; Zero Page,X
		indU8[0] = MemoryIn2Parts[PC8[1]][PC8[0]];
		PC16[0]++;//For the byte-read above
		indU8[0]+=Register[X];//automatically loops
		Register[A] ^= ZeroPage[indU8[0]];
		Flag_Zero = !Register[A];
		Flag_Negative = (SignedRegister[A] < 0);
	},
	() => {//$56 LSR Cycles=6 Bytes=2; Zero Page,X
		console.log("56 LSR was run");
	},
	IllegalOpcode,//$57
	() => {//$58 CLI Cycles=2 Bytes=1; Implied
		console.log("58 CLI was run");
	},
	() => {//$59 EOR Cycles=4-5 Bytes=3; Absolute,Y
		console.log("59 EOR was run");
	},
	IllegalOpcode,//$5A
	IllegalOpcode,//$5B
	IllegalOpcode,//$5C
	() => {//$5D EOR Cycles=4-5 Bytes=3; Absolute,X
		console.log("5D EOR was run");
	},
	() => {//$5E LSR Cycles=7 Bytes=3; Absolute,X
		console.log("5E LSR was run");
	},
	IllegalOpcode,//$5F
	() => {//$60 RTS Cycles=6 Bytes=1; Implied
		Register[SP]++;
		indU8[0] = TheStack[Register[SP]];
		Register[SP]++;
		indU8[1] = TheStack[Register[SP]];
		PC16[0] = indU16[0];
		PC16[0]++;
	},
	() => {//$61 ADC Cycles=6 Bytes=2; (Indirect,X)
		console.log("61 ADC was run");
	},
	HaltAndCatchFire,//$62
	IllegalOpcode,//$63
	IllegalOpcode,//$64
	() => {//$65 ADC Cycles=3 Bytes=2; Zero Page
		console.log("65 ADC was run");
	},
	() => {//$66 ROR Cycles=5 Bytes=2; Zero Page
		indU8[0] = MemoryIn2Parts[PC8[1]][PC8[0]];
		PC16[0]++;//For the byte-read above
		indU8[1] = ZeroPage[indU8[0]];
		const newCarry = !!(indU8[1]&1);
		anotherTempByte[0] = (indU8[1]>>>1)|(Flag_Carry<<7);
		ZeroPage[indU8[0]] = anotherTempByte[0];
		Flag_Carry = newCarry;
		Flag_Zero = !anotherTempByte[0];
		Flag_Negative = !!(anotherTempByte[0]>>>7);
	},
	IllegalOpcode,//$67
	() => {//$68 PLA Cycles=4 Bytes=1; Implied
		Register[SP]++;
		Register[A] = TheStack[Register[SP]];
		Flag_Zero = !Register[A];
		Flag_Negative = (SignedRegister[A] < 0);
	},
	() => {//$69 ADC Cycles=2 Bytes=2; Immediate
		anotherTempByte[0] = MemoryIn2Parts[PC8[1]][PC8[0]];
		PC16[0]++;//For the byte-read above
		indU16[0] = Register[A]+anotherTempByte[0]+Flag_Carry;
		Flag_Overflow = ( ~(Register[A]^anotherTempByte[0]) & (Register[A]^indU16[0]) & 0x80 ) != 0;//I have no idea what's happening here, I just copied this best I could from "Instructions New NES.pdf"
		Register[A] = indU8[0];
		Flag_Carry = !!(indU8[1]);
		Flag_Zero = !Register[A];
		Flag_Negative = (SignedRegister[A] < 0);
	},
	() => {//$6A ROR Cycles=2 Bytes=1; Accumulator
		const newCarry = !!(Register[A]&1);
		Register[A] = (Register[A]>>>1)|(Flag_Carry<<7);
		Flag_Carry = newCarry;
		Flag_Zero = !Register[A];
		Flag_Negative = (SignedRegister[A] < 0);
	},
	IllegalOpcode,//$6B (Undocumented:ARR)
	() => {//$6C JMP Cycles=5 Bytes=3; Indirect
		indU8[0] = MemoryIn2Parts[PC8[1]][PC8[0]];
		PC16[0]++;//For the byte-read above
		indU8[1] = MemoryIn2Parts[PC8[1]][PC8[0]];
		//indirect pointer now in indU16
		PC8[0] = MemoryIn2Parts[indU8[1]][indU8[0]];
		indU8[0]++;//bumping only this part simulates the page-bug correctly
		PC8[1] = MemoryIn2Parts[indU8[1]][indU8[0]];
	},
	() => {//$6D ADC Cycles=4 Bytes=3; Absolute
		console.log("6D ADC was run");
	},
	() => {//$6E ROR Cycles=6 Bytes=3; Absolute
		console.log("6E ROR was run");
	},
	IllegalOpcode,//$6F
	() => {//$70 BVS Cycles=2-5 Bytes=2; Relative
		indU8[0] = MemoryIn2Parts[PC8[1]][PC8[0]];
		PC16[0]++;//For the byte-read above
		if(Flag_Overflow)//Branch condition
		{
			PC16[0]+=ind8[0];//operand counts as signed
			//Possibly add 1 to cycle count
			//also possibly compare PC8[0] to former for more cycle counts
		}
	},
	() => {//$71 ADC Cycles=5-6 Bytes=2; (Indirect),Y
		console.log("71 ADC was run");
	},
	HaltAndCatchFire,//$72
	IllegalOpcode,//$73
	IllegalOpcode,//$74
	() => {//$75 ADC Cycles=4 Bytes=2; Zero Page,X
		anotherTempByte[0] = MemoryIn2Parts[PC8[1]][PC8[0]];
		PC16[0]++;//For the byte-read above
		anotherTempByte[0]+=Register[X];
		anotherTempByte[0] = ZeroPage[anotherTempByte[0]];
		indU16[0] = Register[A]+anotherTempByte[0]+Flag_Carry;
		Flag_Overflow = ( ~(Register[A]^anotherTempByte[0]) & (Register[A]^indU16[0]) & 0x80 ) != 0;//I have no idea what's happening here, I just copied this best I could from "Instructions New NES.pdf"
		Register[A] = indU8[0];
		Flag_Carry = !!(indU8[1]);
		Flag_Zero = !Register[A];
		Flag_Negative = (SignedRegister[A] < 0);
	},
	() => {//$76 ROR Cycles=6 Bytes=2; Zero Page,X
		console.log("76 ROR was run");
	},
	IllegalOpcode,//$77
	() => {//$78 SEI Cycles=2 Bytes=1; Implied
		Flag_ID = true;
	},
	() => {//$79 ADC Cycles=4-5 Bytes=3; Absolute,Y
		console.log("79 ADC was run");
	},
	IllegalOpcode,//$7A
	IllegalOpcode,//$7B
	IllegalOpcode,//$7C
	() => {//$7D ADC Cycles=4-5 Bytes=3; Absolute,X
		console.log("7D ADC was run");
	},
	() => {//$7E ROR Cycles=7 Bytes=3; Absolute,X
		console.log("7E ROR was run");
	},
	IllegalOpcode,//$7F
	IllegalOpcode,//$80
	() => {//$81 STA Cycles=6 Bytes=2; (Indirect,X)
		anotherTempByte[0] = MemoryIn2Parts[PC8[1]][PC8[0]];
		PC16[0]++;//For the byte-read above
		anotherTempByte[0]+=Register[X];
		indU8[0] = ZeroPage[anotherTempByte[0]];
		anotherTempByte[0]++;
		indU8[1] = ZeroPage[anotherTempByte[0]];
		writer(indU8[0],indU8[1],Register[A]);
	},
	IllegalOpcode,//$82
	IllegalOpcode,//$83
	() => {//$84 STY Cycles=3 Bytes=2; Zero Page
		indU8[0] = MemoryIn2Parts[PC8[1]][PC8[0]];
		PC16[0]++;//For the byte-read above
		ZeroPage[indU8[0]] = Register[Y];
	},
	() => {//$85 STA Cycles=3 Bytes=2; Zero Page
		indU8[0] = MemoryIn2Parts[PC8[1]][PC8[0]];
		PC16[0]++;//For the byte-read above
		ZeroPage[indU8[0]] = Register[A];
	},
	() => {//$86 STX Cycles=3 Bytes=2; Zero Page
		indU8[0] = MemoryIn2Parts[PC8[1]][PC8[0]];
		PC16[0]++;//For the byte-read above
		ZeroPage[indU8[0]] = Register[X];
	},
	() => {//IllegalOpcode, $87 SAX Cycles=3 Bytes=2; Zero Page
		indU8[0] = MemoryIn2Parts[PC8[1]][PC8[0]];
		PC16[0]++;//For the byte-read above
		ZeroPage[indU8[0]] = (Register[A] & Register[X]);
		//Unknown what this opcode does to the flags
	},
	() => {//$88 DEY Cycles=2 Bytes=1; Implied
		Register[Y]--;
		Flag_Zero = !Register[Y];
		Flag_Negative = (SignedRegister[Y] < 0);
	},
	IllegalOpcode,//$89
	() => {//$8A TXA Cycles=2 Bytes=1; Implied
		Register[A] = Register[X];
		Flag_Zero = !Register[A];
		Flag_Negative = (SignedRegister[A] < 0);
	},
	IllegalOpcode,//$8B (Undocumented:ANE)
	() => {//$8C STY Cycles=4 Bytes=3; Absolute
		indU8[0] = MemoryIn2Parts[PC8[1]][PC8[0]];
		PC16[0]++;//For the byte-read above
		indU8[1] = MemoryIn2Parts[PC8[1]][PC8[0]];
		PC16[0]++;//For the byte-read above
		writer(indU8[0],indU8[1],Register[Y]);
	},
	() => {//$8D STA Cycles=4 Bytes=2; Absolute
		indU8[0] = MemoryIn2Parts[PC8[1]][PC8[0]];
		PC16[0]++;//For the byte-read above
		indU8[1] = MemoryIn2Parts[PC8[1]][PC8[0]];
		PC16[0]++;//For the byte-read above
		writer(indU8[0],indU8[1],Register[A]);
	},
	() => {//$8E STX Cycles=4 Bytes=3; Absolute
		indU8[0] = MemoryIn2Parts[PC8[1]][PC8[0]];
		PC16[0]++;//For the byte-read above
		indU8[1] = MemoryIn2Parts[PC8[1]][PC8[0]];
		PC16[0]++;//For the byte-read above
		writer(indU8[0],indU8[1],Register[X]);
	},
	IllegalOpcode,//$8F
	() => {//$90 BCC Cycles=2-5 Bytes=2; Relative
		indU8[0] = MemoryIn2Parts[PC8[1]][PC8[0]];
		PC16[0]++;//For the byte-read above
		if(!Flag_Carry)//Branch condition
		{
			PC16[0]+=ind8[0];//operand counts as signed
			//Possibly add 1 to cycle count
			//also possibly compare PC8[0] to former for more cycle counts
		}
	},
	() => {//$91 STA Cycles=6 Bytes=2; (Indirect),Y
		anotherTempByte[0] = MemoryIn2Parts[PC8[1]][PC8[0]];
		PC16[0]++;//For the byte-read above
		indU8[0] = ZeroPage[anotherTempByte[0]];
		anotherTempByte[0]++;
		indU8[1] = ZeroPage[anotherTempByte[0]];
		indU16[0]+=Register[Y];
		writer(indU8[0],indU8[1],Register[A]);
	},
	HaltAndCatchFire,//$92
	IllegalOpcode,//$93 (Undocumented:SHA)
	() => {//$94 STY Cycles=4 Bytes=2; Zero Page,X
		indU8[0] = MemoryIn2Parts[PC8[1]][PC8[0]];
		PC16[0]++;//For the byte-read above
		indU8[0]+=Register[X];
		ZeroPage[indU8[0]] = Register[Y];
	},
	() => {//$95 STA Cycles=4 Bytes=2; Zero Page,X
		indU8[0] = MemoryIn2Parts[PC8[1]][PC8[0]];
		PC16[0]++;//For the byte-read above
		indU8[0]+=Register[X];
		ZeroPage[indU8[0]] = Register[A];
	},
	() => {//$96 STX Cycles=4 Bytes=2; Zero Page,Y
		indU8[0] = MemoryIn2Parts[PC8[1]][PC8[0]];
		PC16[0]++;//For the byte-read above
		indU8[0]+=Register[Y];
		ZeroPage[indU8[0]] = Register[X];
	},
	IllegalOpcode,//$97
	() => {//$98 TYA Cycles=2 Bytes=1; Implied
		Register[A] = Register[Y];
		Flag_Zero = !Register[A];
		Flag_Negative = (SignedRegister[A] < 0);
	},
	() => {//$99 STA Cycles=5 Bytes=3; Absolute,Y
		console.log("99 STA was run");
	},
	() => {//$9A TXS Cycles=2 Bytes=1; Implied
		Register[SP] = Register[X];
	},
	IllegalOpcode,//$9B (Undocumented:SHS)
	IllegalOpcode,//$9C (Undocumented:SHY)
	() => {//$9D STA Cycles=5 Bytes=3; Absolute,X
		indU8[0] = MemoryIn2Parts[PC8[1]][PC8[0]];
		PC16[0]++;//For the byte-read above
		indU8[1] = MemoryIn2Parts[PC8[1]][PC8[0]];
		PC16[0]++;//For the byte-read above
		indU16[0]+=Register[X];
		writer(indU8[0],indU8[1],Register[A]);
	},
	IllegalOpcode,//$9E (Undocumented:SHX)
	IllegalOpcode,//$9F (Undocumented:SHA)
	() => {//$A0 LDY Cycles=2 Bytes=2; Immediate
		Register[Y] = MemoryIn2Parts[PC8[1]][PC8[0]];
		PC16[0]++;//For the byte-read above
		Flag_Zero = !Register[Y];
		Flag_Negative = (SignedRegister[Y] < 0);
	},
	() => {//$A1 LDA Cycles=6 Bytes=2; (Indirect,X)
		anotherTempByte[0] = MemoryIn2Parts[PC8[1]][PC8[0]];
		PC16[0]++;//For the byte-read above
		anotherTempByte[0]+=Register[X];
		indU8[0] = ZeroPage[anotherTempByte[0]];
		anotherTempByte[0]++;
		indU8[1] = ZeroPage[anotherTempByte[0]];
		Register[A] = MemoryIn2Parts[indU8[1]][indU8[0]];
		Flag_Zero = !Register[A];
		Flag_Negative = (SignedRegister[A] < 0);
	},
	() => {//$A2 LDX Cycles=2 Bytes=2; Immediate
		Register[X] = MemoryIn2Parts[PC8[1]][PC8[0]];
		PC16[0]++;//For the byte-read above
		Flag_Zero = !Register[X];
		Flag_Negative = (SignedRegister[X] < 0);
	},
	IllegalOpcode,//$A3
	() => {//$A4 LDY Cycles=3 Bytes=2; Zero Page
		indU8[0] = MemoryIn2Parts[PC8[1]][PC8[0]];
		PC16[0]++;//For the byte-read above
		Register[Y] = ZeroPage[indU8[0]];
		Flag_Zero = !Register[Y];
		Flag_Negative = (SignedRegister[Y] < 0);
	},
	() => {//$A5 LDA Cycles=3 Bytes=2; Zero Page
		indU8[0] = MemoryIn2Parts[PC8[1]][PC8[0]];
		PC16[0]++;//For the byte-read above
		Register[A] = ZeroPage[indU8[0]];
		Flag_Zero = !Register[A];
		Flag_Negative = (SignedRegister[A] < 0);
	},
	() => {//$A6 LDX Cycles=3 Bytes=2; Zero Page
		indU8[0] = MemoryIn2Parts[PC8[1]][PC8[0]];
		PC16[0]++;//For the byte-read above
		Register[X] = ZeroPage[indU8[0]];
		Flag_Zero = !Register[X];
		Flag_Negative = (SignedRegister[X] < 0);
	},
	IllegalOpcode,//$A7
	() => {//$A8 TAY Cycles=2 Bytes=1; Implied
		Register[Y] = Register[A];
		Flag_Zero = !Register[Y];
		Flag_Negative = (SignedRegister[Y] < 0);
	},
	() => {//$A9 LDA Cycles=2 Bytes=2; Immediate
		Register[A] = MemoryIn2Parts[PC8[1]][PC8[0]];
		PC16[0]++;//For the byte-read above
		Flag_Zero = !Register[A];
		Flag_Negative = (SignedRegister[A] < 0);
	},
	() => {//$AA TAX Cycles=2 Bytes=1; Implied
		Register[X] = Register[A];
		Flag_Zero = !Register[X];
		Flag_Negative = (SignedRegister[X] < 0);
	},
	IllegalOpcode,//$AB (Undocumented:LXA)
	() => {//$AC LDY Cycles=4 Bytes=3; Absolute
		indU8[0] = MemoryIn2Parts[PC8[1]][PC8[0]];
		PC16[0]++;//For the byte-read above
		indU8[1] = MemoryIn2Parts[PC8[1]][PC8[0]];
		PC16[0]++;//For the byte-read above
		Register[Y] = MemoryIn2Parts[indU8[1]][indU8[0]];
		Flag_Zero = !Register[Y];
		Flag_Negative = (SignedRegister[Y] < 0);
	},
	() => {//$AD LDA Cycles=4 Bytes=3; Absolute
		indU8[0] = MemoryIn2Parts[PC8[1]][PC8[0]];
		PC16[0]++;//For the byte-read above
		indU8[1] = MemoryIn2Parts[PC8[1]][PC8[0]];
		PC16[0]++;//For the byte-read above
		Register[A] = MemoryIn2Parts[indU8[1]][indU8[0]];
		Flag_Zero = !Register[A];
		Flag_Negative = (SignedRegister[A] < 0);
	},
	() => {//$AE LDX Cycles=4 Bytes=3; Absolute
		indU8[0] = MemoryIn2Parts[PC8[1]][PC8[0]];
		PC16[0]++;//For the byte-read above
		indU8[1] = MemoryIn2Parts[PC8[1]][PC8[0]];
		PC16[0]++;//For the byte-read above
		Register[X] = MemoryIn2Parts[indU8[1]][indU8[0]];
		Flag_Zero = !Register[X];
		Flag_Negative = (SignedRegister[X] < 0);
	},
	IllegalOpcode,//$AF
	() => {//$B0 BCS Cycles=2-5 Bytes=2; Relative
		indU8[0] = MemoryIn2Parts[PC8[1]][PC8[0]];
		PC16[0]++;//For the byte-read above
		if(Flag_Carry)//Branch condition
		{
			PC16[0]+=ind8[0];//operand counts as signed
			//Possibly add 1 to cycle count
			//also possibly compare PC8[0] to former for more cycle counts
		}
	},
	() => {//$B1 LDA Cycles=5-6 Bytes=2; (Indirect),Y
		anotherTempByte[0] = MemoryIn2Parts[PC8[1]][PC8[0]];
		PC16[0]++;//For the byte-read above
		indU8[0] = ZeroPage[anotherTempByte[0]];
		anotherTempByte[0]++;
		indU8[1] = ZeroPage[anotherTempByte[0]];
		indU16[0]+=Register[Y];
		Register[A] = MemoryIn2Parts[indU8[1]][indU8[0]];
		Flag_Zero = !Register[A];
		Flag_Negative = (SignedRegister[A] < 0);
	},
	HaltAndCatchFire,//$B2
	IllegalOpcode,//$B3
	() => {//$B4 LDY Cycles=4 Bytes=2; Zero Page,X
		indU8[0] = MemoryIn2Parts[PC8[1]][PC8[0]];
		PC16[0]++;//For the byte-read above
		indU8[0]+=Register[X];//automatically loops
		Register[Y] = ZeroPage[indU8[0]];
		Flag_Zero = !Register[Y];
		Flag_Negative = (SignedRegister[Y] < 0);
	},
	() => {//$B5 LDA Cycles=4 Bytes=2; Zero Page,X
		indU8[0] = MemoryIn2Parts[PC8[1]][PC8[0]];
		PC16[0]++;//For the byte-read above
		indU8[0]+=Register[X];//automatically loops
		Register[A] = ZeroPage[indU8[0]];
		Flag_Zero = !Register[A];
		Flag_Negative = (SignedRegister[A] < 0);
	},
	() => {//$B6 LDX Cycles=4 Bytes=2; Zero Page,Y
		indU8[0] = MemoryIn2Parts[PC8[1]][PC8[0]];
		PC16[0]++;//For the byte-read above
		indU8[0]+=Register[Y];//automatically loops
		Register[X] = ZeroPage[indU8[0]];
		Flag_Zero = !Register[X];
		Flag_Negative = (SignedRegister[X] < 0);
	},
	IllegalOpcode,//$B7
	() => {//$B8 CLV Cycles=2 Bytes=1; Implied
		Flag_Overflow = false;
	},
	() => {//$B9 LDA Cycles=4-5 Bytes=3; Absolute,Y
		indU8[0] = MemoryIn2Parts[PC8[1]][PC8[0]];
		PC16[0]++;//For the byte-read above
		indU8[1] = MemoryIn2Parts[PC8[1]][PC8[0]];
		PC16[0]++;//For the byte-read above
		indU16[0]+=Register[Y];
		//Possibly use anotherTempByte to check if page boundry crossed
		Register[A] = MemoryIn2Parts[indU8[1]][indU8[0]];
		Flag_Zero = !Register[A];
		Flag_Negative = (SignedRegister[A] < 0);
	},
	() => {//$BA TSX Cycles=2 Bytes=1; Implied
		Register[X] = Register[SP];
		Flag_Zero = !Register[X];
		Flag_Negative = (SignedRegister[X] < 0);
	},
	IllegalOpcode,//$BB
	() => {//$BC LDY Cycles=4-5 Bytes=3; Absolute,X
		indU8[0] = MemoryIn2Parts[PC8[1]][PC8[0]];
		PC16[0]++;//For the byte-read above
		indU8[1] = MemoryIn2Parts[PC8[1]][PC8[0]];
		PC16[0]++;//For the byte-read above
		indU16[0]+=Register[X];
		//Possibly use anotherTempByte to check if page boundry crossed
		Register[Y] = MemoryIn2Parts[indU8[1]][indU8[0]];
		Flag_Zero = !Register[Y];
		Flag_Negative = (SignedRegister[Y] < 0);
	},
	() => {//$BD LDA Cycles=4-5 Bytes=3; Absolute,X
		indU8[0] = MemoryIn2Parts[PC8[1]][PC8[0]];
		PC16[0]++;//For the byte-read above
		indU8[1] = MemoryIn2Parts[PC8[1]][PC8[0]];
		PC16[0]++;//For the byte-read above
		indU16[0]+=Register[X];
		//Possibly use anotherTempByte to check if page boundry crossed
		Register[A] = MemoryIn2Parts[indU8[1]][indU8[0]];
		Flag_Zero = !Register[A];
		Flag_Negative = (SignedRegister[A] < 0);
	},
	() => {//$BE LDX Cycles=4-5 Bytes=3; Absolute,Y
		indU8[0] = MemoryIn2Parts[PC8[1]][PC8[0]];
		PC16[0]++;//For the byte-read above
		indU8[1] = MemoryIn2Parts[PC8[1]][PC8[0]];
		PC16[0]++;//For the byte-read above
		indU16[0]+=Register[Y];
		//Possibly use anotherTempByte to check if page boundry crossed
		Register[X] = MemoryIn2Parts[indU8[1]][indU8[0]];
		Flag_Zero = !Register[X];
		Flag_Negative = (SignedRegister[X] < 0);
	},
	IllegalOpcode,//$BF
	() => {//$C0 CPY Cycles=2 Bytes=2; Immediate
		indU8[0] = MemoryIn2Parts[PC8[1]][PC8[0]];
		PC16[0]++;//For the byte-read above
		indU8[1] = Register[Y]-indU8[0];
		Flag_Zero = (Register[Y] == indU8[0]);
		Flag_Negative = (ind8[1] < 0);
		Flag_Carry = (Register[Y] >= indU8[0]);
	},
	() => {//$C1 CMP Cycles=6 Bytes=2; (Indirect,X)
		console.log("C1 CMP was run");
	},
	IllegalOpcode,//$C2
	IllegalOpcode,//$C3
	() => {//$C4 CPY Cycles=3 Bytes=2; Zero Page
		console.log("C4 CPY was run");
	},
	() => {//$C5 CMP Cycles=3 Bytes=2; Zero Page
		console.log("C5 CMP was run");
	},
	() => {//$C6 DEC Cycles=5 Bytes=2; Zero Page
		indU8[0] = MemoryIn2Parts[PC8[1]][PC8[0]];
		PC16[0]++;//For the byte-read above
		ZeroPage[indU8[0]]--;
		indU8[0] = ZeroPage[indU8[0]];//to check the flags
		Flag_Zero = !indU8[0];
		Flag_Negative = (ind8[0] < 0);
	},
	IllegalOpcode,//$C7
	() => {//$C8 INY Cycles=2 Bytes=1; Implied
		Register[Y]++;
		Flag_Zero = !Register[Y];
		Flag_Negative = (SignedRegister[Y] < 0);
	},
	() => {//$C9 CMP Cycles=2 Bytes=2; Immediate
		indU8[0] = MemoryIn2Parts[PC8[1]][PC8[0]];
		PC16[0]++;//For the byte-read above
		indU8[1] = Register[A]-indU8[0];
		Flag_Zero = (Register[A] == indU8[0]);
		Flag_Negative = (ind8[1] < 0);
		Flag_Carry = (Register[A] >= indU8[0]);
	},
	() => {//$CA DEX Cycles=2 Bytes=1; Implied
		Register[X]--;
		Flag_Zero = !Register[X];
		Flag_Negative = (SignedRegister[X] < 0);
	},
	IllegalOpcode,//$CB (Undocumented:SBX)
	() => {//$CC CPY Cycles=4 Bytes=2; Absolute
		console.log("CC CPY was run");
	},
	() => {//$CD CMP Cycles=4 Bytes=3; Absolute
		console.log("CD CMP was run");
	},
	() => {//$CE DEC Cycles=6 Bytes=3; Absolute
		console.log("CE DEC was run");
	},
	IllegalOpcode,//$CF
	() => {//$D0 BNE Cycles=2-5 Bytes=2; Relative
		indU8[0] = MemoryIn2Parts[PC8[1]][PC8[0]];
		PC16[0]++;//For the byte-read above
		if(!Flag_Zero)//Branch condition
		{
			PC16[0]+=ind8[0];//operand counts as signed
			//Possibly add 1 to cycle count
			//also possibly compare PC8[0] to former for more cycle counts
		}
	},
	() => {//$D1 CMP Cycles=5-6 Bytes=2; (Indirect),Y
		console.log("D1 CMP was run");
	},
	HaltAndCatchFire,//$D2
	IllegalOpcode,//$D3
	IllegalOpcode,//$D4
	() => {//$D5 CMP Cycles=4 Bytes=2; Zero Page,X
		console.log("D5 CMP was run");
	},
	() => {//$D6 DEC Cycles=6 Bytes=2; Zero Page,X
		console.log("D6 DEC was run");
	},
	IllegalOpcode,//$D7
	() => {//$D8 CLD Cycles=2 Bytes=1; Implied
		Flag_Decimal = false;
	},
	() => {//$D9 CMP Cycles=4-5 Bytes=3; Absolute,Y
		console.log("D9 CMP was run");
	},
	IllegalOpcode,//$DA
	IllegalOpcode,//$DB
	IllegalOpcode,//$DC
	() => {//$DD CMP Cycles=4-5 Bytes=3; Absolute,X
		console.log("DD CMP was run");
	},
	() => {//$DE DEC Cycles=7 Bytes=3; Absolute,X
		console.log("DE DEC was run");
	},
	IllegalOpcode,//$DF
	() => {//$E0 CPX Cycles=2 Bytes=2; Immediate
		indU8[0] = MemoryIn2Parts[PC8[1]][PC8[0]];
		PC16[0]++;//For the byte-read above
		indU8[1] = Register[X]-indU8[0];
		Flag_Zero = (Register[X] == indU8[0]);
		Flag_Negative = (ind8[1] < 0);
		Flag_Carry = (Register[X] >= indU8[0]);
	},
	() => {//$E1 SBC Cycles=6 Bytes=2; (Indirect,X)
		console.log("E1 SBC was run");
	},
	IllegalOpcode,//$E2
	IllegalOpcode,//$E3
	() => {//$E4 CPX Cycles=3 Bytes=2; Zero Page
		console.log("E4 CPX was run");
	},
	() => {//$E5 SBC Cycles=3 Bytes=2; Zero Page
		console.log("E5 SBC was run");
	},
	() => {//$E6 INC Cycles=5 Bytes=2; Zero Page
		indU8[0] = MemoryIn2Parts[PC8[1]][PC8[0]];
		PC16[0]++;//For the byte-read above
		ZeroPage[indU8[0]]++;
		indU8[0] = ZeroPage[indU8[0]];//to check the flags
		Flag_Zero = !indU8[0];
		Flag_Negative = (ind8[0] < 0);
	},
	IllegalOpcode,//$E7
	() => {//$E8 INX Cycles=2 Bytes=1; Implied
		Register[X]++;
		Flag_Zero = !Register[X];
		Flag_Negative = (SignedRegister[X] < 0);
	},
	() => {//$E9 SBC Cycles=2 Bytes=1; Immediate
		anotherTempByte[0] = MemoryIn2Parts[PC8[1]][PC8[0]];
		PC16[0]++;//For the byte-read above
		ind16[0] = Register[A]-anotherTempByte[0]-(!Flag_Carry);
		Flag_Overflow = ((Register[A]^anotherTempByte[0]) & (Register[A]^ind16[0]) & 0x80) != 0;//This comes directly from 100th_Coin's patreon post
		Register[A] = ind16[0];
		Flag_Zero = !Register[A];
		Flag_Negative = (SignedRegister[A] < 0);
		Flag_Carry = (ind16[0] > 0);
		//TODO: Check if the carry flag should be set if the subtraction yields exactly 0
	},
	() => {//$EA NOP Cycles=2 Bytes=1; Implied
		//You get nothing! Good day, sir!
	},
	IllegalOpcode,//$EB
	() => {//$EC CPX Cycles=4 Bytes=3; Absolute
		console.log("EC CPX was run");
	},
	() => {//$ED SBC Cycles=4 Bytes=3; Absolute
		console.log("ED SBC was run");
	},
	() => {//$EE INC Cycles=6 Bytes=3; Absolute
		console.log("EE INC was run");
	},
	IllegalOpcode,//$EF
	() => {//$F0 BEQ Cycles=2-5 Bytes=2; Relative
		indU8[0] = MemoryIn2Parts[PC8[1]][PC8[0]];
		PC16[0]++;//For the byte-read above
		if(Flag_Zero)//Branch condition
		{
			PC16[0]+=ind8[0];//operand counts as signed
			//Possibly add 1 to cycle count
			//also possibly compare PC8[0] to former for more cycle counts
		}
	},
	() => {//$F1 SBC Cycles=5-6 Bytes=2; (Indirect),Y
		console.log("F1 SBC was run");
	},
	HaltAndCatchFire,//$F2
	IllegalOpcode,//$F3
	IllegalOpcode,//$F4
	() => {//$F5 SBC Cycles=4 Bytes=2; Zero Page,X
		console.log("F5 SBC was run");
	},
	() => {//$F6 INC Cycles=6 Bytes=2; Zero Page,X
		console.log("F6 INC was run");
	},
	IllegalOpcode,//$F7
	() => {//$F8 SED Cycles=2 Bytes=1; Implied
		Flag_Decimal = true;
	},
	() => {//$F9 SBC Cycles=4-5 Bytes=3; Absolute,Y
		console.log("F9 SBC was run");
	},
	IllegalOpcode,//$FA
	IllegalOpcode,//$FB
	IllegalOpcode,//$FC
	() => {//$FD SBC Cycles=4-5 Bytes=3; Absolute,X
		console.log("FD SBC was run");
	},
	() => {//$FE INC Cycles=7 Bytes=3; Absolute,X
		console.log("FE INC was run");
	},
	IllegalOpcode //$FF
];Object.freeze(NESCPU);

const Palette_2C02G = [//w can be set to 1.0 in the fragment shader
	//0                      1                        2                        3                        4                        5                        6                        7                        8                        9                        A                        B                        C                        D                        E      F
	98/255,98/255,98/255,    0/255,28/255,149/255,    25/255,4/255,172/255,    66/255,0/255,157/255,    97/255,0/255,107/255,    110/255,0/255,37/255,    101/255,5/255,0/255,     73/255,30/255,0/255,     34/255,55/255,0/255,     0/255,73/255,0/255,      0/255,79/255,0/255,      0/255,72/255,22/255,     0/255,53/255,94/255,     0,0,0,                   0,0,0, 0,0,0,
	171/255,171/255,171/255, 12/255,78/255,219/255,   61/255,46/255,255/255,   113/255,21/255,243/255,  155/255,11/255,185/255,  176/255,18/255,98/255,   169/255,39/255,4/255,    137/255,70/255,0/255,    87/255,102/255,0/255,    35/255,127/255,0/255,    0/255,137/255,0/255,     0/255,131/255,50/255,    0/255,109/255,144/255,   0,0,0,                   0,0,0, 0,0,0,
	1,1,1,                   87/255,165/255,255/255,  130/255,135/255,255/255, 180/255,109/255,255/255, 223/255,96/255,255/255,  248/255,99/255,198/255,  248/255,116/255,109/255, 222/255,144/255,32/255,  179/255,174/255,0/255,   129/255,200/255,0/255,   86/255,213/255,34/255,   61/255,211/255,111/255,  62/255,193/255,200/255,  78/255,78/255,78/255,    0,0,0, 0,0,0,
	1,1,1,                   190/255,224/255,255/255, 205/255,212/255,255/255, 224/255,202/255,255/255, 241/255,196/255,255/255, 252/255,196/255,239/255, 253/255,202/255,206/255, 245/255,212/255,175/255, 230/255,223/255,156/255, 211/255,233/255,154/255, 194/255,239/255,168/255, 183/255,239/255,196/255, 182/255,234/255,229/255, 184/255,184/255,184/255, 0,0,0, 0,0,0
];Object.freeze(Palette_2C02G);
/*
Opcodes to do: (in parenths = done, but call reader or writer or both)
($0E),  $1E,  $25,{$26},($29),  $2C, $2D,($2E),
  $36,  $39,  $3D,  $3E,  $4E,  $56,  $58,  $59,  $5D, $5E,
  $61,  $65,{$66},{$69},  $6D,  $6E,  $71,{$75},  $76, $79, $7D, $7E,
  $81,($8C),($8D),($8E),($91),  $99,($9D),
{$C0},  $C1,  $C4,  $C5,  $C9,  $CC,  $CD,  $CE,  $D1, $D5, $D6, $D9, $DD, $DE,
{$E0},  $E1,  $E4,  $E5,  $EC,  $ED,  $EE,  $F1,  $F5, $F6, $F9, $FD, $FE
*/
const MemoryIn2Parts = new Array(0x100).fill(null);//Object.seal doesn't prevent popping
const RawRAM = new ArrayBuffer(0x800);
const RAMpart1 = new Uint8Array(RawRAM,0,0x100);//The Zero Page
const RAMpart2 = new Uint8Array(RawRAM,0x100,0x100);//The stack?
const RAMpart3 = new Uint8Array(RawRAM,0x200,0x100);
const RAMpart4 = new Uint8Array(RawRAM,0x300,0x100);
const RAMpart5 = new Uint8Array(RawRAM,0x400,0x100);
const RAMpart6 = new Uint8Array(RawRAM,0x500,0x100);
const RAMpart7 = new Uint8Array(RawRAM,0x600,0x100);
const RAMpart8 = new Uint8Array(RawRAM,0x700,0x100);
MemoryIn2Parts[0] = RAMpart1;
MemoryIn2Parts[1] = RAMpart2;
MemoryIn2Parts[2] = RAMpart3;
MemoryIn2Parts[3] = RAMpart4;
MemoryIn2Parts[4] = RAMpart5;
MemoryIn2Parts[5] = RAMpart6;
MemoryIn2Parts[6] = RAMpart7;
MemoryIn2Parts[7] = RAMpart8;
MemoryIn2Parts[8] = RAMpart1;
MemoryIn2Parts[9] = RAMpart2;
MemoryIn2Parts[10] = RAMpart3;
MemoryIn2Parts[11] = RAMpart4;
MemoryIn2Parts[12] = RAMpart5;
MemoryIn2Parts[13] = RAMpart6;
MemoryIn2Parts[14] = RAMpart7;
MemoryIn2Parts[15] = RAMpart8;//0xF
MemoryIn2Parts[16] = RAMpart1;//0x10
MemoryIn2Parts[17] = RAMpart2;
MemoryIn2Parts[18] = RAMpart3;
MemoryIn2Parts[19] = RAMpart4;
MemoryIn2Parts[20] = RAMpart5;
MemoryIn2Parts[21] = RAMpart6;
MemoryIn2Parts[22] = RAMpart7;
MemoryIn2Parts[23] = RAMpart8;
MemoryIn2Parts[24] = RAMpart1;
MemoryIn2Parts[25] = RAMpart2;
MemoryIn2Parts[26] = RAMpart3;
MemoryIn2Parts[27] = RAMpart4;
MemoryIn2Parts[28] = RAMpart5;
MemoryIn2Parts[29] = RAMpart6;
MemoryIn2Parts[30] = RAMpart7;
MemoryIn2Parts[31] = RAMpart8;//0x1F

const RawPPUregs = new ArrayBuffer(8);//remember to bitwise and with 7 before interacting with this
const PPUregs = new Uint8Array(RawPPUregs);
MemoryIn2Parts[32] = PPUregs;//0x20
MemoryIn2Parts[33] = PPUregs;
MemoryIn2Parts[34] = PPUregs;
MemoryIn2Parts[35] = PPUregs;
MemoryIn2Parts[36] = PPUregs;
MemoryIn2Parts[37] = PPUregs;
MemoryIn2Parts[38] = PPUregs;
MemoryIn2Parts[39] = PPUregs;
MemoryIn2Parts[40] = PPUregs;
MemoryIn2Parts[41] = PPUregs;
MemoryIn2Parts[42] = PPUregs;
MemoryIn2Parts[43] = PPUregs;
MemoryIn2Parts[44] = PPUregs;
MemoryIn2Parts[45] = PPUregs;
MemoryIn2Parts[46] = PPUregs;
MemoryIn2Parts[47] = PPUregs;//0x2F
MemoryIn2Parts[48] = PPUregs;//0x30
MemoryIn2Parts[49] = PPUregs;
MemoryIn2Parts[50] = PPUregs;
MemoryIn2Parts[51] = PPUregs;
MemoryIn2Parts[52] = PPUregs;
MemoryIn2Parts[53] = PPUregs;
MemoryIn2Parts[54] = PPUregs;
MemoryIn2Parts[55] = PPUregs;
MemoryIn2Parts[56] = PPUregs;
MemoryIn2Parts[57] = PPUregs;
MemoryIn2Parts[58] = PPUregs;
MemoryIn2Parts[59] = PPUregs;
MemoryIn2Parts[60] = PPUregs;
MemoryIn2Parts[61] = PPUregs;
MemoryIn2Parts[62] = PPUregs;
MemoryIn2Parts[63] = PPUregs;//0x3F
const PPUCTRL=0, PPUMASK=1, PPUSTATUS=2, OAMADDR=3, OAMDATA=4, PPUSCROLL=5, PPUADDR=6, PPUDATA=7;
/*
Next up is 64 (0x40), Audio Processing Unit for 0x20 bytes(less than a single part),
but those seem to only go up to 0x4017 inclusive...
0x4016 - controller port 1
0x4017 - controller port 2
"To read the controller, you need to 'clock' the controller once per button,
by reading from the port, returning the state of a single button per read.
There is a shift register inside the controller, and each 'clock' will update
the register, preparing another bit for the next time the port is read.
There are 8 buttons on the controller..."
 - 100th Coin in 'How Inaccurate are Nintendo's Official Emulators?' (oYjYmSniQyM)
The normal controller is called NES004, apparently. (nAStgQzPrAQ)
MemoryIn2Parts[64]  - APU and cartridge expansion rom?
MemoryIn2Parts[95]  - cartridge expansion rom?
MemoryIn2Parts[96]  - SRAM start?
MemoryIn2Parts[127] - SRAM end?
MemoryIn2Parts[128] - PRG start?
MemoryIn2Parts[255] - PRG end?

64-95 (0x40-0x5F) = APU,I/O Registers and "Don't worry about this". Open Bus.
96-127 (0x60-0x7F) = SRAM/WRAM (8K)
128-255 = ROM (32K)

Other sources:
0x4000 to 0x4017 - Registers, mostly APU
0x4018 to 0x5FFF - Cartridge Expansion ROM / Open Bus?
0x6000 to 0x7FFF - Cartridge SRAM / PRG RAM? / Open Bus?
0x8000 and up - Cartridge PRG-ROM
*/
const ZeroPage = MemoryIn2Parts[0];
const TheStack = MemoryIn2Parts[1];

const HCPC = 0xFF;
const NMI = 0xFA;
const startup = 0xFC;
const IRQ = 0xFE;

const indbuffer = new ArrayBuffer(2);//Exists to simulate the indirect mode page overflow bug; as temp values elsewhere.
const indU8 = new Uint8Array(indbuffer);//Do NOT rely on this keeping its value between operations.
const ind8 = new Int8Array(indbuffer);//For reading negative numbers
const indU16 = new Uint16Array(indbuffer);//For overflow checking
const ind16 = new Int16Array(indbuffer);//Exclusively for setting the overflow flag on subtract-with-carry
const RawRegisterBuffer = new ArrayBuffer(4);
const Register = new Uint8Array(RawRegisterBuffer);
const SignedRegister = new Int8Array(RawRegisterBuffer);
const anotherTempByte = new Uint8Array(1);
const A = 0;
const X = 1;
const Y = 2;
const SP = 3;
//For status - I decided on a bunch of booleans. Shifting treats true as 1
let Flag_Negative=false,Flag_Overflow=false, Flag_B=false,Flag_Decimal=false,Flag_ID=false,Flag_Zero=false,Flag_Carry=false;
const statusToByte = () => {
	"use strict";
	return (Flag_Negative<<7)|(Flag_Overflow<<6)|(1<<5)|(Flag_B<<4)|(Flag_Decimal<<3)|(Flag_ID<<2)|(Flag_Zero<<1)|(Flag_Carry<<0);
};
const byteToStatus = (B) => {
	"use strict";
	Flag_Carry = (B&1)==1;
	Flag_Zero = ((B>>>1)&1)==1;
	Flag_ID = ((B>>>2)&1)==1;
	Flag_Decimal = ((B>>>3)&1)==1;
	Flag_B = ((B>>>4)&1)==1;
	Flag_Overflow = ((B>>>6)&1)==1;
	Flag_Negative = ((B>>>7)&1)==1;
};
const PCbuffer = new ArrayBuffer(2);//Program Counter
const PC8 = new Uint8Array(PCbuffer);
const PC16 = new Uint16Array(PCbuffer);
function nextCommand()
{
	indU16[0] = PC16[0]++;//Fetch opcode and increment it
	const OpCode = MemoryIn2Parts[indU8[1]][indU8[0]];
	//possibly poll for interrupts here
	//console.log(`From 0x${indU16[0].toString(16).toUpperCase()}, running 0x${OpCode.toString(16).toUpperCase()}. A=${Register[A]}, X=${Register[X]}, Y=${Register[Y]}`);
	//console.log(`${ZeroPage[0]},${ZeroPage[1]},${ZeroPage[2]},${ZeroPage[3]},${ZeroPage[4]},${ZeroPage[5]},${ZeroPage[6]},${ZeroPage[7]}`);
	NESCPU[OpCode]();//run the fetched opcode
}
//let PF_
const PPUmemIn2parts = new Array(64).fill(null);//64 = 0x40. From 0 to 0x3F
const rawPPU_PatternTables = new ArrayBuffer(0x2000);//half the total...
const PPU_FullPatternTables = new Uint8Array(rawPPU_PatternTables);//for looping over the entire pattern table memory
for(let i=0;i<32;i++)
{
	PPUmemIn2parts[i] = new Uint8Array(rawPPU_PatternTables,i*0x100,0x100);
}
const rawPPU_NameTableA = new ArrayBuffer(0x400);
const PPU_NameTableA_Part1 = new Uint8Array(rawPPU_NameTableA,0,0x100);
const PPU_NameTableA_Part2 = new Uint8Array(rawPPU_NameTableA,0x100,0x100);
const PPU_NameTableA_Part3 = new Uint8Array(rawPPU_NameTableA,0x200,0x100);
const PPU_NameTableA_Part4 = new Uint8Array(rawPPU_NameTableA,0x300,0x100);
const rawPPU_NameTableB = new ArrayBuffer(0x400);
const PPU_NameTableB_Part1 = new Uint8Array(rawPPU_NameTableB,0,0x100);
const PPU_NameTableB_Part2 = new Uint8Array(rawPPU_NameTableB,0x100,0x100);
const PPU_NameTableB_Part3 = new Uint8Array(rawPPU_NameTableB,0x200,0x100);
const PPU_NameTableB_Part4 = new Uint8Array(rawPPU_NameTableB,0x300,0x100);
const rawSpritePalette = new ArrayBuffer(0x20);
const PPU_SpritePalette = new Uint8Array(rawSpritePalette);
//any setup of PPU resting state should be done around here
PPUmemIn2parts[32] = PPU_NameTableA_Part1;
PPUmemIn2parts[33] = PPU_NameTableA_Part2;
PPUmemIn2parts[34] = PPU_NameTableA_Part3;
PPUmemIn2parts[35] = PPU_NameTableA_Part4;
//the ones between here are set up by one of two functions
PPUmemIn2parts[44] = PPU_NameTableB_Part1;
PPUmemIn2parts[45] = PPU_NameTableB_Part2;
PPUmemIn2parts[46] = PPU_NameTableB_Part3;
PPUmemIn2parts[47] = PPU_NameTableB_Part4;
//Mirrors...
PPUmemIn2parts[48] = PPU_NameTableA_Part1;
PPUmemIn2parts[49] = PPU_NameTableA_Part2;
PPUmemIn2parts[50] = PPU_NameTableA_Part3;
PPUmemIn2parts[51] = PPU_NameTableA_Part4;
//same deal as above
PPUmemIn2parts[60] = PPU_NameTableB_Part1;
PPUmemIn2parts[61] = PPU_NameTableB_Part2;
PPUmemIn2parts[62] = PPU_NameTableB_Part3;
PPUmemIn2parts[63] = PPU_SpritePalette;//bitwise and with 0x1F before interacting with this
function SetUpHorizontalMirroring()
{
	PPUmemIn2parts[36] = PPU_NameTableA_Part1;
	PPUmemIn2parts[37] = PPU_NameTableA_Part2;
	PPUmemIn2parts[38] = PPU_NameTableA_Part3;
	PPUmemIn2parts[39] = PPU_NameTableA_Part4;
	PPUmemIn2parts[40] = PPU_NameTableB_Part1;
	PPUmemIn2parts[41] = PPU_NameTableB_Part2;
	PPUmemIn2parts[42] = PPU_NameTableB_Part3;
	PPUmemIn2parts[43] = PPU_NameTableB_Part4;

	PPUmemIn2parts[52] = PPU_NameTableA_Part1;
	PPUmemIn2parts[53] = PPU_NameTableA_Part2;
	PPUmemIn2parts[54] = PPU_NameTableA_Part3;
	PPUmemIn2parts[55] = PPU_NameTableA_Part4;
	PPUmemIn2parts[56] = PPU_NameTableB_Part1;
	PPUmemIn2parts[57] = PPU_NameTableB_Part2;
	PPUmemIn2parts[58] = PPU_NameTableB_Part3;
	PPUmemIn2parts[59] = PPU_NameTableB_Part4;
}
function SetUpVerticalMirroring()
{
	PPUmemIn2parts[36] = PPU_NameTableB_Part1;
	PPUmemIn2parts[37] = PPU_NameTableB_Part2;
	PPUmemIn2parts[38] = PPU_NameTableB_Part3;
	PPUmemIn2parts[39] = PPU_NameTableB_Part4;
	PPUmemIn2parts[40] = PPU_NameTableA_Part1;
	PPUmemIn2parts[41] = PPU_NameTableA_Part2;
	PPUmemIn2parts[42] = PPU_NameTableA_Part3;
	PPUmemIn2parts[43] = PPU_NameTableA_Part4;

	PPUmemIn2parts[52] = PPU_NameTableB_Part1;
	PPUmemIn2parts[53] = PPU_NameTableB_Part2;
	PPUmemIn2parts[54] = PPU_NameTableB_Part3;
	PPUmemIn2parts[55] = PPU_NameTableB_Part4;
	PPUmemIn2parts[56] = PPU_NameTableA_Part1;
	PPUmemIn2parts[57] = PPU_NameTableA_Part2;
	PPUmemIn2parts[58] = PPU_NameTableA_Part3;
	PPUmemIn2parts[59] = PPU_NameTableA_Part4;
}
/*
0000h-0FFFh   Pattern Table 0 (4K) (256 Tiles)
1000h-1FFFh   Pattern Table 1 (4K) (256 Tiles)
2000h-23FFh   Name Table 0 and Attribute Table 0 (1K) (32x30 BG Map) {NameTables A and B appear twice each in this part}
2400h-27FFh   Name Table 1 and Attribute Table 1 (1K) (32x30 BG Map)
2800h-2BFFh   Name Table 2 and Attribute Table 2 (1K) (32x30 BG Map)
2C00h-2FFFh   Name Table 3 and Attribute Table 3 (1K) (32x30 BG Map)
3000h-3EFFh   Mirror of 2000h-2EFFh
3F00h-3F1Fh   Background and Sprite Palettes (25 entries used) {indexes into palette (do N*3 to N*3+2), PatternTable in turn indexes into this 4-long array;3F00 is the default background}
3F20h-3FFFh   Mirrors of 3F00h-3F1Fh

Sound stuff:
2 pulse wave channels
1 triangle wave channel
1 noise channel
1 sample playing channel
*/
function reader(mem0,mem1,a,i)
{
	//returns 0-255, can be read into a typedarray if negativity matters. Should handle side-effects that come from reading.
	//	alternatively, return nothing, add an array-parameter and put the read value there (did this)
	//zero page: Generally bypasses this function
	//1 to 31: May read directly
	//32 to 63: bitwise and with 7...
	//128 to 255: May read directly after slotting in the arrays from cartridge
	if(mem1 >=32 && mem1 < 64)
	{
		mem0 = mem0&7;
		/* check other roms for reads to 0x2002
		switch(mem0)
		{
			case PPUSTATUS:
				a[i] = 0x80;
				return;
			default:
				break;
		}
		*/
		if(mem0 == PPUSTATUS){console.log("PPU status read");}
	}
	a[i] = MemoryIn2Parts[mem1]?.[mem0]??0;//failing reads return 0 - expand on this later
}
function writer(mem0,mem1,val)
{
	//returns nothing, should handle PPU and APU shenanigans.
	//128 to 255 may be ignored unless game's cartridge has special hardware, future issue.
	if(mem1>=64){return;}
	if(mem1>=32)
	{
		mem0 = mem0&7;
		switch(mem0)
		{
			case PPUCTRL://0
			case PPUMASK://1
			case PPUSTATUS://2
			case OAMADDR://3
			case OAMDATA://4
			case PPUSCROLL://5
			case PPUADDR://6
			case PPUDATA://7
				console.log("Writing call to PPU register "+mem0);
				break;
			default:
				console.log("I don't know how, but you broke math");
				return;
		}
	}
	MemoryIn2Parts[mem1][mem0] = val;
}

const NROMNCHARsize = 32784;
const NROMw2Kchr = 40976;
let CartBlob = null;//files will be loaded into this
let fH = null, PPUarrayFromCart = null;
function resetTheNES()
{
	switch(CartBlob?.byteLength)
	{
		case NROMw2Kchr:
			//I put this into the start of PPU_Memory, though I'm not sure about this
			PPUarrayFromCart = new Uint8Array(CartBlob,0x8010,0x2000);//this is enough for both pattern tables
			PPU_FullPatternTables.set(PPUarrayFromCart);//just efficient copying, no view transfer shenanigans. Larger part of original is unchanged, perfect.
		case NROMNCHARsize:
			for(let i=0;i<128;i++)//load from the cartridge into 0x8000 to 0xFFFF
			{
				MemoryIn2Parts[128+i] = new Uint8Array(CartBlob,i*0x100+16,0x100);
			}
			fH = new Uint8Array(CartBlob,0,16);//file header
			break;
		default:
			console.log(`Can only read files with length exactly ${NROMNCHARsize} or ${NROMw2Kchr}`);
			return;
	}
	Flag_ID = true;
	Register[SP] = 0xFD;
	PC8[0] = MemoryIn2Parts[HCPC][startup];
	PC8[1] = MemoryIn2Parts[HCPC][startup+1];

	for(let i=0;i<8192;i++){UCIoIPT(i);}//try to find a more efficient way to do this

	[SetUpHorizontalMirroring,SetUpVerticalMirroring][(fH[6]&1)]();
}
function rdHeader()
{
	if(fH)
	{
		console.log(fH.toString());
		console.log(`PRG-ROM size: ${fH[4]*16}kb`);
		console.log(`CHR-ROM size: ${fH[4]*8}kb`);
		console.log( ((fH[6]&1)==1)?"Vertical mirroring (horizontal scrolling)":"Horizontal mirroring (vertical scrolling)" );
		console.log("persistent memory?",((fH[6]&2)==0)?"No":"Yes");
	}
	else
	{
		console.log("file not loaded");
	}
}
</script>
<style>
canvas
{
	background-color:#000000;/*Because it's turned off*/
}
input
{
	margin-top:1px;
	margin-bottom:1px;
}
summary
{
	cursor:pointer;
}
fieldset
{
	display:inline-block;
}
pre
{
	background-color:#F7F7F7;
}
</style>
</head>
<body>
<canvas id="tvcanvas" width="682" height="522"></canvas>
<hr>
<table border=1><tbody><tr><td valign=top>
.NES file reader (no mappers)<br>
<input type=file id="cartFP"><br>
<input type=button value="Load blob" onclick=readCartFile()><br>
<div id="logFP">Log space</div>
</td><td valign=top>
<input type=button value="Reset" onclick=resetTheNES()><br>
<input type=button value="Next command" onclick=nextCommand()>
</td></tr></tbody></table>
<details><summary>Memory viewers</summary>
<table border=1>
<thead><tr><th>RAM</th><th>Registers</th><th>Flags</th></tr></thead>
<tbody><tr>
<td valign=top>Later...</td>
<td valign=top>
<input type=button value="Examine registers" onclick=examineRegisters()><br>
A : <span id="showA"></span><br>
X : <span id="showX"></span><br>
Y : <span id="showY"></span><br>
SP : <span id="showSP"></span><br>
PC : <span id="showPC"></span>
</td><td>
<input type=button value="Examine flags" onclick=examineFlags()><br>
N : <span id="flagN">Flag_Negative</span><br>
V : <span id="flagV">Flag_Overflow</span><br>
B : <span id="flagB">Flag_B</span><br>
D : <span id="flagD">Flag_Decimal</span><br>
I : <span id="flagI">Flag_ID</span><br>
Z : <span id="flagZ">Flag_Zero</span><br>
C : <span id="flagC">Flag_Carry</span>
</td>
</tr></tbody>
</table>
<table border=1>
<tbody><tr><td>
<input type=button value="View pattern tables" onclick=VisPatTab()><br>
<pre id="PTV"></pre>
</td></tr></tbody>
</table>
</details>
<script type="text/javascript" src="webgl-utils.txt"></script>
<script type="text/javascript" src="MV.txt"></script>
<script>
//this part is for the canvas and all that it needs, like WebGL
/* handle keyboard-as-controller here
window.onkeydown = (k) => {
	if(!k.repeat)console.log(k);
};
window.onkeyup = (k) => {
	//
};
*/

const pRows = 261;
const pCols = 341;
const buffer = 0.00;
const rStep = (2.0-2*buffer)/pRows;
const cStep = (2.0-2*buffer)/pCols;
const rAdd = rStep/2.0;
const cAdd = rStep/2.0;
const pixelArray = [];
for(let aY=pRows-1;aY>=0;aY--)
{
	for(let aX=0;aX<pCols;aX++)
	{
		pixelArray.push(vec2(cAdd+aX*cStep-1,rAdd+aY*rStep-1));
	}
}
const FPA = flatten(pixelArray);//this goes into pixPos
const ActualGLcolors = new Float32Array(pRows*pCols*3);//pre-flattened, this goes into pixCol
for(let i=0;i<ActualGLcolors.length;i++)
{
	ActualGLcolors[i] = Math.random();
}
const colorIndexer = new Uint8Array(pRows*pCols);
for(let i=0;i<colorIndexer.length;i++)//actually, try to use colors that could actually happen
{
	colorIndexer[i] = Math.floor(Math.random()*64);
	
	ActualGLcolors[i*3] = Palette_2C02G[colorIndexer[i]*3];
	ActualGLcolors[i*3+1] = Palette_2C02G[colorIndexer[i]*3+1];
	ActualGLcolors[i*3+2] = Palette_2C02G[colorIndexer[i]*3+2];
	
}
const Dcanvas = document.getElementById("tvcanvas");
//Dcanvas.onclick = (k) => {};
const gl = WebGLUtils.setupWebGL(Dcanvas);
if(!gl){alert("WebGL isn't available");}
gl.viewport(0,0,Dcanvas.width,Dcanvas.height);
gl.clearColor(0.95,0.95,0.95,1.0);//this may become the way to set the default background
//gl.enable(gl.DEPTH_TEST);//probably not
const vertShdr = gl.createShader(gl.VERTEX_SHADER);
const fragShdr = gl.createShader(gl.FRAGMENT_SHADER);
const program = gl.createProgram();
const VertexShaderCode =
"attribute vec4 pixPos;\
attribute vec3 pixCol;\
varying vec3 handoff;\
void main()\
{\
	gl_PointSize = 2.0;\
	gl_Position = pixPos;\
	handoff = pixCol;\
}";
gl.shaderSource(vertShdr,VertexShaderCode);
gl.compileShader(vertShdr);
/*
Check gl.getShaderParameter(vertShdr,gl.COMPILE_STATUS) here
and gl.getShaderInfoLog(vertShdr)
*/
const FragmentShaderCode =
"precision mediump float;\
varying vec3 handoff;\
void main()\
{\
	gl_FragColor.xyz = handoff;\
	gl_FragColor.w = 1.0;\
}";
gl.shaderSource(fragShdr,FragmentShaderCode);
gl.compileShader(fragShdr);
/*
Check gl.getShaderParameter(fragShdr,gl.COMPILE_STATUS) here
and gl.getShaderInfoLog(fragShdr)
*/
gl.attachShader(program,vertShdr);
gl.attachShader(program,fragShdr);
gl.linkProgram(program);
/*
Check gl.getProgramParameter(program,gl.LINK_STATUS) here
and gl.getProgramInfoLog(program)
*/
gl.useProgram(program);

const bufferId1 = gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER,bufferId1);
gl.bufferData(gl.ARRAY_BUFFER,FPA,gl.STATIC_DRAW);

const JSpixPos = gl.getAttribLocation(program,"pixPos");
gl.vertexAttribPointer(JSpixPos,2,gl.FLOAT,false,0,0);
gl.enableVertexAttribArray(JSpixPos);

const bufferId2 = gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER,bufferId2);
gl.bufferData(gl.ARRAY_BUFFER,ActualGLcolors,gl.STATIC_DRAW);

const JSpixCol = gl.getAttribLocation(program,"pixCol");
gl.vertexAttribPointer(JSpixCol,3,gl.FLOAT,false,0,0);
gl.enableVertexAttribArray(JSpixCol);

//const JSusedPalette = gl.getUniformLocation(program,"colorPile");
//gl.uniform3fv(JSusedPalette,Palette_2C02G);
/*
The idea was to make Palette_2C02G a uniform array of vec3s,
and have pixCol and handoff be single-byte uints indexing into it in the fragment shader.
Turns out nvidia didn't facilitate that until later, so for sake of old computers, don't.
*/

function drawFrame()
{
	gl.clear(gl.COLOR_BUFFER_BIT);
	gl.drawArrays(gl.POINTS,0,pixelArray.length);
}
</script>
<script>
//this part is for things that require page elements to be there

const DcartFP = document.getElementById("cartFP");
const DlogFP = document.getElementById("logFP");
const DshowA = document.getElementById("showA");
const DshowX = document.getElementById("showX");
const DshowY = document.getElementById("showY");
const DshowSP = document.getElementById("showSP");
const DshowPC = document.getElementById("showPC");
const DflagN = document.getElementById("flagN");
const DflagV = document.getElementById("flagV");
const DflagB = document.getElementById("flagB");
const DflagD = document.getElementById("flagD");
const DflagI = document.getElementById("flagI");
const DflagZ = document.getElementById("flagZ");
const DflagC = document.getElementById("flagC");
const DPTV = document.getElementById("PTV");
function readCartFile()
{
	if(DcartFP==null)
	{
		DlogFP.innerText = "File picker not found";
		return;
	}
	if(DcartFP.files.length < 1)
	{
		DlogFP.innerText = "No file picked";
		return;
	}
	DcartFP.files[0].arrayBuffer().then((daBuf) => {
		CartBlob = daBuf;
		return DcartFP.files[0].name;
	}).then((cartName) => {
		if(CartBlob.byteLength != NROMNCHARsize && CartBlob.byteLength != NROMw2Kchr)
		{
			DlogFP.innerText = `File length is ${CartBlob.byteLength} (0x${CartBlob.byteLength.toString(16).toUpperCase()}),\nexpected either \n${NROMNCHARsize} (0x${NROMNCHARsize.toString(16).toUpperCase()})\n or ${NROMw2Kchr} (0x${NROMw2Kchr.toString(16).toUpperCase()})`;
		}
		else//proper length
		{
			DlogFP.innerText = `${cartName} blob has been loaded`;
		}
	}).catch((error) => {
		DlogFP.innerText = error.toString();
	});
//to use: String.fromCharCode(csvs)
}
function examineRegisters()
{
	DshowA.innerText = `${Register[A]} (0x${Register[A].toString(16).toUpperCase()})`;
	DshowX.innerText = `${Register[X]} (0x${Register[X].toString(16).toUpperCase()})`;
	DshowY.innerText = `${Register[Y]} (0x${Register[Y].toString(16).toUpperCase()})`;
	DshowSP.innerText = `${Register[SP]} (0x${Register[SP].toString(16).toUpperCase()})`;
	DshowPC.innerText = `${PC16[0]} (0x${PC16[0].toString(16).toUpperCase()})`;
}
function examineFlags()
{
	DflagN.innerText = Flag_Negative;
	DflagV.innerText = Flag_Overflow;
	DflagB.innerText = Flag_B;
	DflagD.innerText = Flag_Decimal;
	DflagI.innerText = Flag_ID;
	DflagZ.innerText = Flag_Zero;
	DflagC.innerText = Flag_Carry;
}
const CindA = new Array(16384).fill(0);//Color index array. 16384 = 0x4000.
//if PPU resting state ever gets implemented, remove the fill and call some recalc function instead
function UCIoIPT(a)//Update Color Index of Intermediary Pattern Table
{//to be called after changing the PPU's RAM
	if(!(a >= 0 && a<=8192))
	{
		console.log("SCI called with parameter "+a);
		return;
	}
	//8*8*16*16 = 0x4000 - screen is apparently 16 tiles across, each tile is 8*8
	//each screen is 0x1000 bytes (4096), each byte is a line in a tile, but it takes 2 bytes to color a tile fully
	//8 lines per tile, twice = 256 tiles (0x100). (So on average, each byte covers 4 tiles)

	const PrB = PPU_FullPatternTables[a];
	const TileRowSkips = Math.floor(a/256);
	const WiRp = a%256;//Within Row position
	const SingleRowTileSkips = Math.floor(WiRp/16);
	const WiTp = WiRp%16;//Within Tile position
	const BQ = Math.floor(WiTp/8)+1;//which bit this byte affects
	const PP = WiTp%8;//pixel within tile

	const StartingPoint = TileRowSkips*1024+SingleRowTileSkips*8+(128*PP);

	const BM = [//BitMask
		((PrB>>7)&1),
		((PrB>>6)&1),
		((PrB>>5)&1),
		((PrB>>4)&1),
		((PrB>>3)&1),
		((PrB>>2)&1),
		((PrB>>1)&1),
		(PrB&1)
	];
	for(let i=0;i<8;i++)
	{
		if(BM[i])//set
		{
			CindA[StartingPoint+i] |= BQ;
		}
		else//clear
		{
			CindA[StartingPoint+i] &= (~BQ);
		}
	}
}
function VisPatTab()//Stands for Visualize Pattern Table, relies on the CindA
{
	const LL = 128;//16 tiles per row on screen * 8 pixels per row within a tile = 128
	//const fs = CindA.join("");
	const fs = CindA.map((x) => ["","","",""][x]??"?").join("");
	let ws = fs.substring(0,LL);
	for(let i=128;i<fs.length;i+=LL)
	{
		const temp = fs.substring(i,i+LL);
		ws = ws.concat("\n",temp);
	}
	DPTV.innerText = ws;
}
</script>
</body>
</html>